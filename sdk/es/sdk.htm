
h1.Referencia del SDK

ep.Mientras que los civiles (es decir, los no programadores) a menudo fantasean con ganar la lotería, el equivalente para muchos programadores es la rara oportunidad de crear una nueva librería desde cero, sin las restricciones que a menudo frustran sus deseos de ampliar y mejorar una biblioteca existente.
<i>Philip J. Schneider</i> - Industrial Light + Magic

img(sdk_big_picture.svg,300,.35).Arquitectura de NAppGUI.
Esquema de dependencias del SDK NAppGUI.

li(orange_block.png,24).Paquetes que no contienen código dependiente de plataforma.

li(green_block.png,24).Paquetes que contienen código dependiente de plataforma bajo una interfaz común.

li.<lp>sewer</lp>: Tipos básicos, asserts, Unicode.

li.<lp>osbs</lp>: Servicios del sistema operativo. API portable sobre archivos, directorios, procesos, hebras, memoria, etc.

li.<lp>core</lp>: Utilidades no gráficas de uso común. Auditor de memoria, estructuras de datos, canales E/S, MVVM, etc.

li.<lp>geom2d</lp>: Geometría 2D. Transformaciones, vectores, etc.

li.<lp>draw2d</lp>: API de dibujo vectorial, imágenes y fuentes tipográficas, que conecta con las tecnologías nativas de cada sistema operativo.

li.<lp>gui</lp>: Compositor de interfaces de usuario de alto nivel.

li.<lp>osapp</lp>: Aplicaciones de escritorio. Ciclo de mensajes.

li.<lp>inet</lp>: Protocolos y servicios de Internet. Http, Ftp, Google, etc.

p.La implementación de NAppGUI se ha dividido en varias librerías estáticas escritas en ANSI-C (C90) con pequeñas partes en C++98 <r>sdk_big_picture</r>. El proyecto compila sin problemas en todas las versiones de Visual Studio (desde VS2005), Xcode (desde 3) y GCC (desde 4). Se puede utilizar para el desarrollo de aplicaciones de alto rendimiento escritas en C en los sistemas Windows, macOS y Linux. Se ha marcado una clara línea que separa los paquetes orientados a cálculo y acceso a datos <i>(back-end)</i> de aquellos destinados a las capas de presentación o interfaz <i>(front-end)</i>. También hemos seguido ciertos <lh>Estándares</lh> cuyas bases se centralizan en la librería <lp>sewer</lp>, que si bien no incorpora mucha funcionalidad, si que define los tipos básicos y las macros de configuración comunes a todo el proyecto.

h2.Un poco de historia

p.Empecé a trabajar en este proyecto de manera inconsciente, a mediados del año 2008 cuando estaba finalizando mis estudios de Ingeniería Informática en la Universidad de Alicante. Quería desarrollar un simulador de sistemas físicos que funcionase tanto en ordenadores PC-Windows como en los iMac de Apple sin que por ello tuviese que duplicar todo el trabajo. Las alternativas tecnológicas de la época, como GTK o Qt, no me convencían en absoluto ya que eran demasiado pesadas, complicadas de utilizar y lentas por lo que acabarían empañando la calidad, elegancia y empeño que estaba poniendo en mis algoritmos de cálculo matemático. Después de perder varios meses evaluando diferentes librerías para la programación multiplataforma descargué unos manuales técnicos de Apple para programar directamente en Cocoa, la tecnología base del fabricante de la manzanita para desarrollar software sobre iMac. A mediados de 2010 empecé a ver los primeros resultados y esto fue alentador. Había creado una aplicación con el prototipo de mi simulador en apenas 500Kb <r>imech</r>, en contraste con los más de 30Mb de dependencias exigidos por las soluciones de terceros. El código era compacto y limpio, la aplicación funcionaba a velocidad de vértigo y, sobre todo, tenía una apariencia profesional que recordaba en parte al iMovie, permitía manipular vistas 3D como en un videojuego y aportaba datos técnicos de la simulación en tiempo real. Esto me inspiró a seguir trabajando en trazar una barrera entre la parte de la aplicación reutilizable y aquella dependiente de una tecnología concreta. Esto permitiría adaptar mi simulador a diferentes modelos de ordenador y sistemas operativos.

img(imech.png,0,.8).Simulador iMech, basado en una versión primitiva de NAppGUI.
Captura del simulador físico iMech.

p.Paralelamente, en Septiembre de 2008 me reincorporo al mercado laboral después de seis años en la Universidad, mercado en el que sigo en la actualidad (Julio 2019), aunque los últimos años trabajo como autónomo desde casa lo que permite organizar la agenda y optimizar mi tiempo al máximo. En estos años no he abandonado mi proyecto personal, he seguido trabajando en él en a tiempo parcial sencillamente por pura afición. Su desarrollo me ha permitido investigar y profundizar en áreas interesantes para mí y reciclarme constantemente. En 2013 hago mi primera incursión en el mundo del emprendimiento siendo co-fundador de iMech Technologies, empresa de software con la que sigo vinculado y cuyo principal objetivo fue la venta del motor de simulación que previamente había creado. Al no plantear una estrategia de marketing sólida, no conseguimos nuestros objetivos iniciales con iMech, pero pudimos reconvertirla incorporando nuevos clientes y, a día de hoy, sigue viva.

p.A mediados de 2015 empiezo a plantearme el hecho de que todo el esfuerzo técnico realizado durante estos años tiene suficiente entidad para convertirse en un producto por si mismo. Fué entonces cuando creo el proyecto NAppGUI y comienzo a migrar todas las librerías de iMech dedicadas al desarrollo multiplataforma. Durante estos últimos años he completado el soporte para <i>Cocoa</i> e incluído el de <i>Win32</i> y <i>Gtk+</i>. He creado esta documentación en Español y en Inglés, ayudándome de los servicios de traducción de Google.

p.El 31 de Diciembre de 2019, subo a GitHub la primera versión pública de NAppGUI.
