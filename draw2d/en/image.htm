langrev.
h1.Images

p.A digital image, also called <i>bitmap</i> or <i>raster graphics</i>, is a set of small colored dots called <b>pixels</b> organized in a rectangular grid. It is characterized by its resolution (width, height) and depth, which is the amount of bits needed to encode each pixel <r>image_resolution</r>.

p.<i>Bitmap</i> images work best for capturing snapshots of the real world, where it is virtually impossible to break the scene into geometric blocks, as we saw in <lp>draw</lp>. On opposite, being composed of discrete points, it does not behave well on size changes where it will suffer a loss of quality.

img(image_resolution.png,520,.65).On the left image of 64x64 pixels and 16 colors. On the right 256x256 pixels and 16 million colors.
The same image in two different resolutions.

h2.Load and view images

p.In most cases, the only thing we will need to know about images will be how to read them from disk or other data source and then display them on the screen as part of the user interface <r>imgcode</r> <r>use_of_images</r>. We consider that the images are stored in one of the standard formats: JPG, PNG, BMP or GIF.

code(cpp,imgcode).Loading and viewing images.
Image *img = image_from_file("lenna.jpg", NULL);
Image *icon = image_from_resource(pack, ekCANCEL);
...
imageview_image(view, img);
button_image(button, icon);
code.

img(use_of_images.svg,460,.65).Integration of images in the user interface.
Reading an image from disk and viewing.

li.Use <lf>image_from_file</lf> to load an image from disk.

li.Use <lf>image_from_data</lf> to create an image from a memory buffer.

li.Use <lf>image_from_resource</lf> to get a picture of a resource package.

li.Use <lf>image_read</lf> to create an image from <lp>stream</lp>.

li.In <lp>urlimg</lp> you have an example of how to download them from a web server.

bq.NAppGUI only supports JPG, PNG, BMF and GIF formats.

p.Once the image object is loaded in memory, we have several ways to view it:

li.Use <lf>draw_image</lf> to draw an image in a 2d context.

li.Use <lf>imageview_image</lf> to assign an image to a view.

li.Use <lf>button_image</lf> to assign an image to a button.

li.Use <lf>popup_add_elem</lf> to assign a text and icon to a drop-down list.

h2.Generate images

p.As we saw in <lp>dctx</lp>, if necessary we can create our own images from geometric primitives. In <lp>drawimg</lp> you have a complete sample application <r>drawimage</r>.

li.Use <lf>dctx_image</lf> to create an image from a 2d context.

img(drawimage.png,0,.8).Image generated by drawing commands.
Image generated from drawing commands.

h2.Pixel access

p.Images are <b>immutable objects</b> optimized for recurring on-screen drawing, so certain licenses are allowed, both in the internal organization of color information and in the management of possible copies. For this reason it is not possible to directly manipulate the pixels, but we must access them using a <lp>pixbuf</lp>. 

li.Use <lf>image_from_pixels</lf> to create an image from the color information.

li.Use <lf>image_from_pixbuf</lf> to create an image from a pixel buffer.

li.Use <lf>image_pixels</lf> to get a buffer with the pixels of the image.

bq.Apple technical documentation: "Treat NSImage and its image representations as immutable objects. The goal of NSImage is to provide an efficient way to display images on the target canvas. Avoid manipulating the data of an image representation directly, especially if there are alternatives to manipulating the data, such as compositing the image and some other content into a new image object."

p.The <b>pixel buffers</b> allow us to optimally manipulate the content of the image. To view the result or store it in any of the supported formats, we must create a new image <r>image_pixels</r>. 

img(image_pixels.svg,620,.8).Image editing process.
Process from a pixel buffer to an image.

h2.Save images: Codecs

p.One of the biggest problems of digital images is the large amount of memory they need. An image of only 1024x768 pixels and 32 bits of color needs 3 megabytes of memory. It may not seem like much, but at the end of the 80s this was a great handicap since memory was very expensive and transmissions were very slow. This is why several coding (compression) systems were devised that reduced the amount of memory needed and that were consolidated with the rise of the Internet <r>file_formats</r>.

li.Use <lf>image_get_codec</lf> to get the <i>codec</i> associated with the image.

li.Use <lf>image_codec</lf> to change the <i>codec</i> associated with the image.

li.Use <lf>image_to_file</lf> to save it to disk.

li.Use <lf>image_write</lf> to write it in a <lt>Stream</lt>.

img(file_formats.svg,360,.5).Image formats supported by NAppGUI.
BMP, GIF, JPG and PNG logos.

li.<b>JPEG:</b> <i>Joint Photographic Experts Group</i> is a format with a very good compression rate based on the Fourier Transform. Ideal for capturing real-world snapshots, although it will detract some quality from the original capture (lossy compression).

li.<b>PNG:</b> <i>Portable Network Graphics</i> emerged in response to legal problems with the GIF format. Supports lossless LZ77/Deflate compression and indexed pixel formats. Ideal for computer generated diagrams, graphics or images.

li.<b>GIF:</b> <i>Graphics Interchange Format</i> uses the proprietary compression algorithm LZW, although the patent expired in 2003. It has survived PNG because it can include animations in a single file, something that neither of the two previous formats supports.

li.<b>BMP:</b> <i>BitMaP</i>. Windows native format widely surpassed by the other three. Although it supports a special type of compression called <i>Run-Length encoding</i>, the truth is that most files are saved uncompressed. BMP files take up much more space, for this reason very little is used on the Internet and almost nothing on non-Windows machines. It is supported by almost all programs and systems because it is very simple an fast to interpret.

p.To be able to display on the screen, the image must be decompressed (de-encoded), a process that is performed automatically when reading the image. When saving it to disk or sending it over the network, the opposite process is performed, compressed or encoded using the algorithm associated with it <r>codecs</r>, but it can be changed.

table(codecs).Default image codecs.
row.
p.Constructor
p.Codec
row.
p.<lf>image_from_file</lf>
p.The original codec.
row.
p.<lf>image_from_data</lf>
p.The original codec.
row.
p.<lf>image_from_resource</lf>
p.The original codec.
row.
p.<lf>image_from_pixels</lf>
p.Transparencies? Yes:<lt>ekPNG</lt> No:<lt>ekJPG</lt>.
row.
p.<lf>dctx_image</lf>
p.<lt>ekPNG</lt>.
table.

func(image_from_pixels).Create an image from an array of pixels.
fret(Image*).The image.
fpar(const uint32_t,width).The image width (in pixels).
fpar(const uint32_t,height).The image height (in pixels).
fpar(const pixformat_t,format).Pixel format.
fpar(const byte_t*,data).Buffer that contains the color value of each pixel. It will depend on the resolution and format.
fpar(const color_t*,palette).Color palette required to render indexed images. If it is <c>NULL</c> a <lh>Predefined palette</lh> will be used if necessary.
fnote.See <lh>Pixel access</lh>.

func(image_from_pixbuf).Create an image from a buffer pixel.
fret(Image*).The image.
fpar(const Pixbuf*,pixbuf).The buffer.
fpar(const Palette*,palette).The palette.
fnote.Equal to <lf>image_from_pixels</lf> avoiding indicating parameters separately.

func(image_from_file).Create an image from a file on disk.
fret(Image*).The image.
fpar(const char_t*,pathname).The file path. <lh>Filename and pathname</lh>.
fpar(ferror_t*,error).Error code if the function fails. Can be <c>NULL</c>.
fnote.Only formats <i>jpg</i>, <i>png</i>, <i>bmp</i> and <i>gif</i> are accepted.

func(image_from_data).Create an image from a buffer containing the encoded data. 
fret(Image*).The image.
fpar(const byte_t*,data).The buffer with the image data.
fpar(const uint32_t,size).The buffer size in bytes.
fnote.The buffer represents data encoded in <i>jpg</i>, <i>png</i>, <i>bmp</i> or <i>gif</i>. To create the image directly from pixels use <lf>image_from_pixels</lf>.

func(image_from_resource).Get an image of a resource package. 
fret(Image*).The image.
fpar(const ResPack*,pack).The resource package.
fpar(const ResId,id).The resource identifier.
fnote.See <lp>resources</lp>.

func(image_rotate).Create a new image by rotating an existing one.
fret(Image*).The newly created image.
fpar(const Image*,image).The original image.
fpar(const real32_t,angle).Angle in radians.
fpar(const bool_t,nsize).<c>TRUE</c> the resulting image will be resized to fit the entire original. <c>FALSE</c> the resulting image will have the same dimensions as the original, cutting part of the content (clipping).
fpar(const color_t,background).Background color. The new image will have "blank" areas due to rotation.

func(image_scale).Create a copy of the image, with a new size.
fret(Image*).The image.
fpar(const Image*,image).The source image.
fpar(const uint32_t,nwidth).The width of the new image. Pass <lt>UINT32_MAX</lt> so that the aspect ratio with respect to <c>nheight</c>.
fpar(const uint32_t,nheight).The height of the new image. Pass <lt>UINT32_MAX</lt> so that the aspect ratio with respect to <c>nwidth</c>.
fnote.If both values <c>nwidth</c>, <c>nheight</c> are <c>UINT32_MAX</c> or the new dimensions are identical to the current ones, the internal reference counter will increase, as is the case in <lf>image_copy</lf>.

func(image_copy).Create a copy of the image.
fret(Image*).The image copy.
fpar(const Image*,image).The source image.
fnote.Images are immutable objects. Copying really means increasing an internal counter without cloning the object. However, the application must destroy the copy with <lf>image_destroy</lf> just like those created with any other constructor. When all copies are destroyed, it will actually be removed from memory.

func(image_read).Create an image from the data read from a <lp>stream</lp>.
fret(Image*).The image.
fpar(Stream*,stm).Input stream. Data encoded in <i>jpg</i>, <i>png</i>, <i>bmp</i> or <i>gif</i> are expected. The function detects the format automatically.

func(image_to_file).Save an image to disk, using the codec associated with it.
fret(bool_t).<c>TRUE</c> if it was saved correctly or <c>FALSE</c> and an error has occurred.
fpar(const Image*,image).The image.
fpar(const char_t*,pathname).The path of the destination file. <lh>Filename and pathname</lh>.
fpar(ferror_t*,error).Error code if the function fails. Can be <c>NULL</c>.
fnote.Use <lf>image_codec</lf> to change the default codec.

func(image_write).Write an image in an output stream, using the codec associated with it.
fpar(Stream*,stm).Writing stream. Data encoded in <i>jpg</i>, <i>png</i>, <i>bmp</i> or <i>gif</i> will be written.
fpar(const Image*,image).The image.
fnote.Use <lf>image_codec</lf> to change the default codec.

func(image_destroy).Destroy the image.
fpar(Image**,image).The image. Will be set to <c>NULL</c> after destruction.

func(image_size).Get image resolution.
fpar(const Image*,image).The image.
fpar(uint32_t*,width).The width of the image in pixels.
fpar(uint32_t*,height).The height of the image in pixels.

func(image_format).Get the pixel format of the image.
fpar(const Image*,image).The image.
fpar(pixformat_t*,format).Pixel format.

func(image_pixels).Get a buffer with the pixels that make up the decoded image.
fpar(const Image*,image).The image.
fpar(const pixformat_t,format).The required pixel format.
fpar(Pixbuf**,pixels).The buffer where the result will be stored. Must be destroyed with <lf>pixbuf_destroy</lf>.
fpar(Palette**,palette).The color palette for indexed images. Must be destroyed with <lf>palette_destroy</lf>. It can be <c>NULL</c>.
fnote.If in <c>pixformat</c> we indicate <lt>ekOPTIMAL</lt> the format that uses the fewest bits without loss of information will be used. <lt>ekFIMAGE</lt> will use the original format of the image. For any other value, the conversion will be carried out if necessary.

func(image_codec).Change the default codec associated with the image.
fpar(const Image*,image).The image.
fpar(const codec_t,codec).The new codec.
fnote.The change will take effect the next time we save or write the image. By default, the image retains the codec with which it was read. When we create it with <lf>image_from_pixels</lf> <lt>ekJPG</lt> codec is assigned as default. For images from 2d contexts <lf>dctx_image</lf>, the default codec is <lt>ekPNG</lt>.
fcode.
Image *img = image_from_file("lenna.jpg", NULL);
Stream *stm = stm_socket(ip, port, NULL, NULL);
image_codec(img, ekPNG);
image_write(socket, img);
fcode.

func(image_get_codec).Get the codec associated with the image.
fret(codec_t).El codec.
fpar(const Image*,image).The image.
fnote.See <lf>image_codec</lf>.

func(image_num_frames).Get the number of sequences in animated images.
fret(uint32_t).The number of sequences or <i>frames</i>.
fpar(const Image*,image).The image.
fnote.Only the <i>gif</i> format supports animations. For the rest 1 will always be returned.

func(image_frame_length).Get the time of an animation sequence.
fret(real32_t).Sequence time in seconds.
fpar(const Image*,image).The image.
fpar(const uint32_t,findex).The frame index.
fnote.Only <i>gif</i> format supports animations.
