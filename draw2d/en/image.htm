langrev.
h1.Images

p.A digital image, also called <i>bitmap</i> or <i>raster graphics</i>, is a set of small colored dots called <b>pixels</b> organized in a rectangular grid. It is characterized by its resolution (width, height) and depth, which is the amount of bits needed to encode each pixel <r>image_resolution</r>.

p.<i>Bitmap</i> images work best for capturing snapshots of the real world, where it is virtually impossible to break the scene into geometric blocks, as we saw in <lp>draw</lp>. On opposite, being composed of discrete points, it does not behave well on size changes where it will suffer a loss of quality.

img(image_resolution.png,520,.65).On the left image of 64x64 pixels and 16 colors. On the right 256x256 pixels and 16 million colors.
The same image in two different resolutions.

h2.Load and view images

p.In most cases, the only thing we will need to know about images will be how to read them from disk or other data source and then display them on the screen as part of the user interface <r>imgcode</r> <r>use_of_images</r>. We consider that the images are stored in one of the standard formats: JPG, PNG, BMP or GIF.

code(cpp,imgcode).Loading and viewing images.
Image *img = image_from_file("lenna.jpg", NULL);
Image *icon = image_from_resource(pack, ekCANCEL);
...
imageview_image(view, img);
button_image(button, icon);
code.

img(use_of_images.svg,460,.65).Integration of images in the user interface.
Reading an image from disk and viewing.

li.Use <lf>image_from_file</lf> to load an image from disk.

li.Use <lf>image_from_data</lf> to create an image from a memory buffer.

li.Use <lf>image_from_resource</lf> to get a picture of a resource package.

li.Use <lf>image_read</lf> to create an image from <lp>stream</lp>.

li.In <lp>urlimg</lp> you have an example of how to download them from a web server.

bq.NAppGUI only supports JPG, PNG, BMF and GIF formats.

p.Once the image object is loaded in memory, we have several ways to view it:

li.Use <lf>draw_image</lf> to draw an image in a 2d context.

li.Use <lf>imageview_image</lf> to assign an image to a view.

li.Use <lf>button_image</lf> to assign an image to a button.

li.Use <lf>popup_add_elem</lf> to assign a text and icon to a drop-down list.

h2.Generate images

p.As we saw in <lp>dctx</lp>, if necessary we can create our own images from geometric primitives. In <lp>drawimg</lp> you have a complete sample application <r>drawimage</r>.

li.Use <lf>dctx_image</lf> to create an image from a 2d context.

img(drawimage.png,0,.8).Image generated by drawing commands.
Image generated from drawing commands.

h2.Pixel access

p.Another way to generate images is through algorithms that calculate the value of each pixel. A clear application of this is found in the representation of fractal sets <r>fractals</r>, an area of mathematics dedicated to the study of certain dynamic systems. In <lp>fractals</lp> you have the complete application.

li.Use <lf>image_from_pixels</lf> to create an image from a buffer.

li.Use <lf>image_pixels</lf> to get a buffer with the image pixels.

img(fractals.png,480,.65).Image generated pixel by pixel using fractal algorithms.
Representation of a Julia set.

p.Images are objects optimized for recurring on-screen drawing, so certain licenses are allowed in the internal organization of color information. For this reason it is not possible to directly manipulate the pixels, but we must access them through an intermediate buffer. A <b>pixbufer</b> <r>pixel_format</r> it is nothing more than a memory area that contains all the pixels sequentially and where each element can be accessed by a simple offset, taking into account the color format <r>accpixel</r>. The algorithms will write directly to this memory and, later, an <lt>Image</lt> object will be created <r>pixel_buffer</r>, to be able to draw it on the screen or send it through the output channels.

img(pixel_format.svg,420,.5).Pixel formats. <b>(a)</b> <lt>ekRGBA32</lt>, <b>(b)</b> <lt>ekRGB24</lt>, <b>(c)</b> <lt>ekGRAY8</lt>.
Visual representation of an array of pixels according to the format.

code(cpp,accpixel).Direct access to the pixel (x, y).
// Pixel format = kRGBA32
byte_t *pixbuf = heap_new_n(width * height * 4, byte_t);
byte_t *pixel = pixbuf + (y * width + x) * 4;
pixel[0] = red;
pixel[1] = green;
pixel[2] = blue;
pixel[3] = alpha;

// Pixel format = kRGB24
byte_t *pixbuf = heap_new_n(width * height * 3, byte_t);
byte_t *pixel = pixbuf + (y * width + x) * 3;
pixel[0] = red;
pixel[1] = green;
pixel[2] = blue;

// Pixel format = kGRAY8
byte_t *pixbuf = heap_new_n(width * height, byte_t);
byte_t *pixel = pixbuf + (y * width + x);
pixel[0] = gray;
code.

img(pixel_buffer.svg,620,.8).Image from the color information.
Process from a pixel buffer to an image.

p.Another application of pixels direct access is the implementation of image filters. In these cases we start by extracting the <b>pixbuf</b> from an existing image <r>image_filter</r>, edit the buffer and create a new image with the result. In <lp>filters</lp> you have the full example application <r>imagefilter</r>.

img(image_filter.svg,620,.8).Basic process of an image filter.
Image filter operation.

img(imagefilter.png,0,.8).Example application of the use of image filters.
Capture an image to which a filter has been applied.

h2.Save images: Codecs

p.One of the biggest problems of digital images is the large amount of memory they need. An image of only 1024x768 pixels and 32 bits of color needs 3 megabytes of memory. It may not seem like much, but at the end of the 80s this was a great handicap since memory was very expensive and transmissions were very slow. This is why several coding (compression) systems were devised that reduced the amount of memory needed and that were consolidated with the rise of the Internet <r>file_formats</r>.

li.Use <lf>image_get_codec</lf> to get the <i>codec</i> associated with the image.

li.Use <lf>image_codec</lf> to change the <i>codec</i> associated with the image.

li.Use <lf>image_to_file</lf> to save it to disk.

li.Use <lf>image_write</lf> to write it in a <lt>Stream</lt>.

img(file_formats.svg,360,.5).Image formats supported by NAppGUI.
BMP, GIF, JPG and PNG logos.

li.<b>JPEG:</b> <i>Joint Photographic Experts Group</i> is a format with a very good compression rate based on the Fourier Transform. Ideal for capturing real-world snapshots, although it will detract some quality from the original capture (lossy compression).

li.<b>PNG:</b> <i>Portable Network Graphics</i> emerged in response to legal problems with the GIF format. Supports lossless LZ77/Deflate compression and indexed pixel formats. Ideal for computer generated diagrams, graphics or images.

li.<b>GIF:</b> <i>Graphics Interchange Format</i> uses the proprietary compression algorithm LZW, although the patent expired in 2003. It has survived PNG because it can include animations in a single file, something that neither of the two previous formats supports.

li.<b>BMP:</b> <i>BitMaP</i>. Windows native format widely surpassed by the other three. Although it supports a special type of compression called <i>Run-Length encoding</i>, the truth is that most files are saved uncompressed. BMP files take up much more space, for this reason very little is used on the Internet and almost nothing on non-Windows machines. It is supported by almost all programs and systems because it is very simple an fast to interpret.

p.To be able to display on the screen, the image must be decompressed (de-encoded), a process that is performed automatically when reading the image. When saving it to disk or sending it over the network, the opposite process is performed, compressed or encoded using the algorithm associated with it <r>codecs</r>, but it can be changed.

table(codecs).Default image codecs.
row.
p.Constructor
p.Codec
row.
p.<lf>image_from_file</lf>
p.The original codec.
row.
p.<lf>image_from_data</lf>
p.The original codec.
row.
p.<lf>image_from_resource</lf>
p.The original codec.
row.
p.<lf>image_from_pixels</lf>
p.<lt>ekJPG</lt>.
row.
p.<lf>dctx_image</lf>
p.<lt>ekPNG</lt>.
table.

func(image_from_pixels).Create an image from an array of pixels.
fret(Image*).The image.
fpar(const uint32_t,width).The image width (in pixels).
fpar(const uint32_t,height).The image height (in pixels).
fpar(const pixformat_t,format).Pixel format.
fpar(const byte_t*,data).Buffer that contains the color value of each pixel. It will depend on the resolution and format.
fnote.See <lh>Pixel access</lh>.

func(image_from_file).Create an image from a file on disk.
fret(Image*).The image.
fpar(const char_t*,pathname).The file path. <lh>Filename and pathname</lh>.
fpar(ferror_t*,error).Error code if the function fails. Can be <c>NULL</c>.
fnote.Only formats <i>jpg</i>, <i>png</i>, <i>bmp</i> and <i>gif</i> are accepted.

func(image_from_data).Create an image from a buffer containing the encoded data. 
fret(Image*).The image.
fpar(const byte_t*,data).The buffer with the image data.
fpar(const uint32_t,size).The buffer size in bytes.
fnote.The buffer represents data encoded in <i>jpg</i>, <i>png</i>, <i>bmp</i> or <i>gif</i>. To create the image directly from pixels use <lf>image_from_pixels</lf>.

func(image_from_resource).Get an image of a resource package. 
fret(Image*).The image.
fpar(const ResPack*,pack).The resource package.
fpar(const ResId,id).The resource identifier.
fnote.See <lp>resources</lp>.

func(image_scale).Create a copy of the image, with a new size.
fret(Image*).The image.
fpar(const Image*,image).The source image.
fpar(const uint32_t,nwidth).The width of the new image. Pass <lt>UINT32_MAX</lt> so that the aspect ratio with respect to <c>nheight</c>.
fpar(const uint32_t,nheight).The height of the new image. Pass <lt>UINT32_MAX</lt> so that the aspect ratio with respect to <c>nwidth</c>.
fnote.If both values <c>nwidth</c>, <c>nheight</c> are <c>UINT32_MAX</c> or the new dimensions are identical to the current ones, the internal reference counter will increase, as is the case in <lf>image_copy</lf>.

func(image_copy).Create a copy of the image.
fret(Image*).The image copy.
fpar(const Image*,image).The source image.
fnote.Images are immutable objects. Copying really means increasing an internal counter without cloning the object. However, the application must destroy the copy with <lf>image_destroy</lf> just like those created with any other constructor. When all copies are destroyed, it will actually be removed from memory.

func(image_read).Create an image from the data read from a <lp>stream</lp>.
fret(Image*).The image.
fpar(Stream*,stm).Input stream. Data encoded in <i>jpg</i>, <i>png</i>, <i>bmp</i> or <i>gif</i> are expected. The function detects the format automatically.

func(image_to_file).Save an image to disk, using the codec associated with it.
fret(bool_t).<c>TRUE</c> if it was saved correctly or <c>FALSE</c> and an error has occurred.
fpar(const Image*,image).The image.
fpar(const char_t*,pathname).The path of the destination file. <lh>Filename and pathname</lh>.
fpar(ferror_t*,error).Error code if the function fails. Can be <c>NULL</c>.
fnote.Use <lf>image_codec</lf> to change the default codec.

func(image_write).Write an image in an output stream, using the codec associated with it.
fpar(Stream*,stm).Writing stream. Data encoded in <i>jpg</i>, <i>png</i>, <i>bmp</i> or <i>gif</i> will be written.
fpar(const Image*,image).The image.
fnote.Use <lf>image_codec</lf> to change the default codec.

func(image_destroy).Destroy the image.
fpar(Image**,image).The image. Will be set to <c>NULL</c> after destruction.

func(image_size).Get image resolution.
fpar(const Image*,image).The image.
fpar(uint32_t*,width).The width of the image in pixels.
fpar(uint32_t*,height).The height of the image in pixels.

func(image_pixformat).Get the pixel format of the image.
fpar(const Image*,image).The image.
fpar(pixformat_t*,format).Pixel format.

func(image_pixels).Get a buffer with the pixels that make up the decoded image.
fpar(const Image*,image).The image.
fpar(uint32_t*,width).The width of the image in pixels. Can be <c>NULL</c>.
fpar(uint32_t*,height).The height of the image in pixels. Can be <c>NULL</c>.
fpar(pixformat_t*,format).The pixel format. Necessary to interpret <c>pixels</c> vector data. Can be <c>NULL</c>.
fpar(Buffer**,pixels).The buffer where the pixels will be stored. It must be destroyed with <lf>buffer_destroy</lf> when it is no longer necessary. Can be <c>NULL</c>.
fnote.See <lh>Pixel access</lh>.

func(image_codec).Change the default codec associated with the image.
fpar(Image*,image).The image.
fpar(const codec_t,codec).The new codec.
fnote.The change will take effect the next time we save or write the image. By default, the image retains the codec with which it was read. When we create it with <lf>image_from_pixels</lf> <lt>ekJPG</lt> codec is assigned as default. For images from 2d contexts <lf>dctx_image</lf>, the default codec is <lt>ekPNG</lt>.
fcode.
Image *img = image_from_file("lenna.jpg", NULL);
Stream *stm = stm_socket(ip, port, NULL, NULL);
image_codec(img, ekPNG);
image_write(socket, img);
fcode.

func(image_get_codec).Get the codec associated with the image.
fret(codec_t).El codec.
fpar(const Image*,image).The image.
fnote.See <lf>image_codec</lf>.

func(image_num_frames).Get the number of sequences in animated images.
fret(uint32_t).The number of sequences or <i>frames</i>.
fpar(const Image*,image).The image.
fnote.Only the <i>gif</i> format supports animations. For the rest 1 will always be returned.

func(image_frame_length).Get the time of an animation sequence.
fret(real32_t).Sequence time in seconds.
fpar(const Image*,image).The image.
fpar(const uint32_t,findex).The frame index.
fnote.Only <i>gif</i> format supports animations.

func(image_bpp).Get the number of bytes per pixel of the format. 
fret(uint32_t).Bytes por pixel.
fpar(const pixformat_t,format).Pixel format.

