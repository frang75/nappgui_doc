langrev.
h1.Portability

ep.It's hard to write software that runs correctly and efficiently. So once a program works in one environment, you don't want to repeat much of the effort if you move it to a different compiler or processor or operating system. <b>Ideally, it should need no changes whatsoever</b>.
Kernighan & Pike - The Practice of Programming.

p.In <lp>quick</lp> and <lp>newprj</lp> we used Visual Studio 2019 to generate the <i>NAppGUI</i> solution. We understand by <b>portability</b> the ability to compile and debug our programs on platforms other than those that were written, without touching a single line of code. We understand by <b>platform</b> the combination of a compiler and a CPU architecture. For example, <c>v142_x64</c> refers to Visual Studio 2019 and Intel 64bits. In <r>portability_steps</r> we see the different steps in the code migration process.

img(portability_steps.svg,620,.85).Stages in the code portability between platforms.
Three Windows, macOS and Linux computers networked to the same source code repository.

li.<b>Working copy:</b> A copy of the project source code must exist on each machine. Normally this will be done through a version control system such as Subversion or Git, although it could also be updated from an external memory.

li.<b>CMake:</b> CMake will create a build project (or solution) from the source code using the scripts in <c>/prj</c> directory of the SDK distribution. This will be done fully automatically.

li.<b>Build:</b> Using Visual Studio, Xcode or GCC the solution will be compiled and the libraries and executables included in it will be generated.

li.<b>Run/Debug:</b> Binaries can already be executed and debugged on the target platform.

h2.Platforms

p.In <r>platforms</r> you have the complete list of supported platforms. In the folder <c>/lib</c> for each project NAppGUI binaries must be present, depending on the platforms on which it should compile. CMake will recognize the contents of this folder and configure the solution in each case.

table(platforms).Platforms supported by NAppGUI.
row.
p.
p.Platform
p.Compiler
p.CPU
p.Minimum S.O.
row.
img(vs2019.png,32,.05).
p.v142_x64
p.VS2019
p.Intel x64
p.Vista
row.
img(vs2019.png,32,.05).
p.v142_x86
p.VS2019
p.Intel x86
p.Vista
row.
img(vs2017.png,32,.05).
p.v141_x64
p.VS2017
p.Intel x64
p.Vista
row.
img(vs2017.png,32,.05).
p.v141_x86
p.VS2017
p.Intel x86
p.Vista
row.
img(vs2017.png,32,.05).
p.v141_xp_x64
p.VS2017
p.Intel x64
p.XP
row.
img(vs2017.png,32,.05).
p.v141_xp_x86
p.VS2017
p.Intel x86
p.XP
row.
img(vs2015.png,32,.05).
p.v140_x64
p.VS2015
p.Intel x64
p.Vista
row.
img(vs2015.png,32,.05).
p.v140_x86
p.VS2015
p.Intel x86
p.Vista
row.
img(vs2015.png,32,.05).
p.v140_xp_x64
p.VS2015
p.Intel x64
p.XP
row.
img(vs2015.png,32,.05).
p.v140_xp_x86
p.VS2015
p.Intel x86
p.XP
row.
img(vs2013.png,32,.05).
p.v120_x64
p.VS2013
p.Intel x64
p.Vista
row.
img(vs2013.png,32,.05).
p.v120_x86
p.VS2013
p.Intel x86
p.Vista
row.
img(vs2013.png,32,.05).
p.v120_xp_x64
p.VS2013
p.Intel x64
p.XP
row.
img(vs2013.png,32,.05).
p.v120_xp_x86
p.VS2013
p.Intel x86
p.XP
row.
img(vs2012.png,32,.05).
p.v110_x64
p.VS2012
p.Intel x64
p.Vista
row.
img(vs2012.png,32,.05).
p.v110_x86
p.VS2012
p.Intel x86
p.Vista
row.
img(vs2012.png,32,.05).
p.v110_xp_x64
p.VS2012
p.Intel x64
p.XP
row.
img(vs2012.png,32,.05).
p.v110_xp_x86
p.VS2012
p.Intel x86
p.XP
row.
img(vs2010.png,32,.05).
p.v100_x64
p.VS2010
p.Intel x64
p.XP
row.
img(vs2010.png,32,.05).
p.v100_x86
p.VS2010
p.Intel x86
p.XP
row.
img(vs2008.png,32,.05).
p.v90_x64
p.VS2008
p.Intel x64
p.XP
row.
img(vs2008.png,32,.05).
p.v90_x86
p.VS2008
p.Intel x86
p.XP
row.
img(vs2005.png,32,.05).
p.v80_x64
p.VS2005
p.Intel x64
p.XP
row.
img(vs2005.png,32,.05).
p.v80_x86
p.VS2005
p.Intel x86
p.XP
row.
img(catalina.png,32,.05).
p.sdk10_15_x64
p.Xcode 11.3
p.Intel x64
p.Catalina
row.
img(mojave.png,32,.05).
p.sdk10_14_x64
p.Xcode 10.2.1
p.Intel x64
p.Mojave
row.
img(high_sierra.png,32,.05).
p.sdk10_13_x64
p.Xcode 9.4.1
p.Intel x64
p.High Sierra
row.
img(sierra.png,32,.05).
p.sdk10_12_x64
p.Xcode 8.3.3
p.Intel x64
p.Sierra
row.
img(el_capitan.png,32,.05).
p.sdk10_11_x64
p.Xcode 7.3.1
p.Intel x64
p.El Capitan
row.
img(yosemite.png,32,.05).
p.sdk10_10_x64
p.Xcode 6.4
p.Intel x64
p.Yosemite
row.
img(mavericks.png,32,.05).
p.sdk10_9_x64
p.Xcode 6.2
p.Intel x64
p.Mavericks
row.
img(mountain_lion.png,32,.05).
p.sdk10_8_x64
p.Xcode 5.1.1
p.Intel x64
p.Mountain Lion
row.
img(lion.png,32,.05).
p.sdk10_7_x64
p.Xcode 4.6.3
p.Intel x64
p.Lion
row.
img(snow_leopard.png,32,.05).
p.sdk10_6_x64
p.Xcode 3.2.6
p.Intel x64
p.Snow Leopard
row.
img(snow_leopard.png,32,.05).
p.sdk10_6_x86
p.Xcode 3.2.6
p.Intel x86
p.Snow Leopard
row.
img(ubuntu20_logo.png,32,.05).
p.gcc9_gtk3_x64
p.GCC 9.3/GTK 3.24
p.Intel x64
p.Ubuntu 20.04 LTS
row.
img(ubuntu_logo.png,32,.05).
p.gcc7_gtk3_x64
p.GCC 7.3.0
p.Intel x64
p.Ubuntu 18.04 LTS
row.
img(ubuntu_logo.png,32,.05).
p.gcc5_gtk3_x64
p.GCC 5.3.1
p.Intel x64
p.Ubuntu 16.04 LTS
row.
img(ubuntu_logo.png,32,.05).
p.gcc5_gtk3_x86
p.GCC 5.3.1
p.Intel x86
p.Ubuntu 16.04 LTS
row.
img(ubuntu_logo.png,32,.05).
p.gcc4_gtk3_x64
p.GCC 4.8.2
p.Intel x64
p.Ubuntu 14.04 LTS
row.
img(ubuntu_logo.png,32,.05).
p.gcc4_gtk3_x86
p.GCC 4.8.2
p.Intel x86
p.Ubuntu 14.04 LTS
row.
img(raspbian.png,32,.05).
p.gcc6_gtk3_arm
p.GCC 6.3.0
p.ARM
p.Raspbian 9.1 Strech
table.

h2.Windows Portability

p.We can use any version of Visual Studio from 2005 to compile under Windows. As we saw on <lp>quick</lp> the first thing we have to do is launch CMake over the source code:

li.<b>Where is the source code:</b> <c>C:\nappgui\src</c>.

li.<b>Where to build the binaries:</b> <c>C:\nappgui_build</c>.

li.Press <c>[Configure]</c> and <c>[Generate]</c>.

p.The first time CMake will ask what version of Visual Studio we want to use <r>cmake_depends_link</r> and that, obviously, we must have installed in the machine in question. The architecture selected by default can be changed from the same dialog <r>generator_platform</r>. 

img(cmake_depends_link.svg,560,.65).Selecting the Visual Studio version from the CMake wizard.
Drop list that shows the different versions of Visual Studio with which we can compile. 

img(generator_platform.png,0,.80).Selection of the architecture in the generator panel.
CMake Optional platform for generator.

p.Once we press <c>[Open Project]</c> , we will have the project ready to compile. From Visual Studio <c>Build->Build Solution</c> and debug <c>Debug->Start Debugging</c> <r>vs2010_debug</r>.

img(vs2010_debug.png,620,.80).Debugging the <i>Die</i> application in Visual Studio 2010.
Visual Studio 2010 debugging a C application.

bq.To change the Visual Studio version we have to clear the CMake cache <c>File->Delete Cache</c> or change the destination directory: <b>Where to build the binaries</b>. It is possible to have different solutions from the same code in several directories, each with its own version of Visual Studio.

p.Starting with Visual Studio 2010, a dissociation occurs between the editor and the compiler. The term <i>Plaform Toolset</i> identifies the compiler, that can be used with more modern IDEs. If we do not indicate anything, CMake will use the toolset included by default in each version of VS, but it can be changed from <i>Optional toolset to use</i>. For example, we can combine <c>Visual Studio 15 2017</c> with the VS2013 toolset <c>v120_xp</c> <r>optional_toolset</r>.

img(optional_toolset.png,-1,.70).Using the toolset <c>v120_xp</c> with the editor of VS2017.
Optional toolset to use in CMake.

h3.Visual C++ Redistributable

p.By default, Visual Studio dynamically links the functions of the C library, which causes the <c>.exe</c> may not work on machines that do not have the <c>VC++</c> DLLs <r>vc_redistributable_error</r>. This forces applications to include a copy of <c>MSVCRT.dll</c>, <c>VCRUNTIME.dll</c>, ... or install the famous <i>Visual C ++ Redistributable</i> packages to ensure the application can run smoothly.

img(vc_redistributable_error.png,600,.90).Error due to lack of VC++ DLLs.
Error message caused by the lack of VC ++ libraries.

p.NAppGUI uses a small set of the C library, and directly accesses the Windows API whenever possible (more details in <lh>Standard C library</lh>). For this reason, all applications created with NAppGUI perform a static link (option <c>/MT</c>) of the stdlib functions that need, avoiding dependencies at the expense of slightly increasing (a few Kb) the size of the final executable. This ensures that applications will run smoothly on all Windows machines without the need for additional DLLs and without having to install the <i>VC++ Redistributable</i>.

bq.NAppGUI applications do not require the Visual C++ Redistributable. Neither do they use the MFC "Microsoft Foundation Classes" nor the .NET platform.

h3.WindowsXP support

p.From VS2012, the <i>Platform Toolset</i> generates executables that are not compatible with WindowsXP. If we want our applications to run on this system, we must select the alternative toolset finished in <c>_xp</c>: <c>V141_xp</c>, <c>V140_xp</c>, <c>V120_xp</c>, <c>V110_xp</c>. Or, <c>v100</c>, <c>v90</c> or <c>v80</c>, that do support XP <r>vs2005_debug</r>.

bq.Support for WindowsXP has been permanently removed in Visual Studio 2019. Platform Toolset v142_xp does not exist.

img(vs2005_debug.png,800,.80).Debugging the <i>Die</i> application in WindowsXP with VS2005 (toolset v80).
Using Visual Studio 2005 in WindowsXP by debugging an application written in C.

bq.NAppGUI does not work on Windows prior to XP or with Visual Studio prior to 2005.

h3.SSE support

p.With the Pentium III, Intel incorporated an additional set of instructions for floating-point operations called SSE <i>Streaming SIMD Extensions</i>. This allows optimizing mathematical calculations at the cost of losing compatibility, since applications that use SSE will not work on Pentium II or earlier models. In NAppGUI the toolset have been reserved <c>v80_x86</c> and <c>v90_x86</c> of Visual Studio to create applications compatible with older processors <r>ssevers</r>. From <c>v100_x86</c>, SSE2 will be used in all the toolset.

table(ssevers).SSE support
row.
p.Toolset
p.SSE
p.Minimum CPU
row.
p.v80_x86
p.x87 (no SSE)
p.Pentium II/AMD K6
row.
p.v90_x86
p.SSE
p.Pentium III/AMD Duron
row.
p.v100_x86
p.SSE2
p.Pentium IV/AMD Sempron
row.
p.v110_x86
p.SSE2
p.Pentium IV/AMD Sempron
row.
p....
p.SSE2
p....
table.

bq.SSE support is only disabled in 32-bit (x86) architectures. All 64-bit (x64) CPUs incorporate SSE2.

h2.macOS portability

p.Compiling on Apple iMac, macBook and macMini follows the same philosophy as in Windows, we will only need CMake and <l>https://developer.apple.com/xcode/''Xcode</l>. As we have already done in Windows, we open CMake and assign the directories:

li.<b>Where is the source code:</b> <c>/Users/fran/nappgui/src</c> (or your <c>WORKING_DIR/nappgui/src</c>).

li.<b>Where to build the binaries:</b> <c>/Users/fran/nappgui_build</c>. Directory where the generated code will go.

p.Press <c>[Configure]</c>. The first time CMake will ask us to select the compiler. Unlike Visual Studio, it only offers one option for Xcode <r>cmake_xcode</r>. We accept, press <c>[Generate]</c> and then <c>[Open Project]</c>.

img(cmake_xcode.png,0,.55).Selection of the Xcode generator in CMake.
Selecting Xcode from the CMake wizard.

p.When opening the Xcode solution <c>(NAppGUI.xcodeproj)</c>, we see the different projects that compose it, including <i>Die</i> and <i>Dice</i>. We select <i>Die</i> in the upper left drop-down and then press <c>Play</c> or <c>Product->Run</c> <r>xcode_debug</r>. This will compile the program and launch it in debug mode, where we can establish breakpoints to inspect the stack and the value of the variables.

img(xcode_debug.png,0,.80).Debugging the <i>Die</i> application in Xcode.
Debugging the Die application from Xcode 10.2.1.

h3.Base SDK and Deployment Target

p.Each year, Apple releases a new version of macOS, which comes with a new SDK and the Xcode update that includes the SDK. 

bq.<b>Base SDK</b> is the version included in each new major version of Xcode, which matches the latest version of the macOS system on the market.

p.Apple has a much more restrictive policy than Microsoft regarding the applications compatibility with earlier versions of the operating system. By default, a program compiled with SDK 10.14 (macOS Mojave) will not work in the immediately previous macOS High Sierra <r>deployment_error</r>.

img(deployment_error.png,400,.45).<i>Die</i> with <i>Base SDK</i> 10.14 will not work in High Sierra.
Error running an application with deployment target 10.14 on macOS High Sierra.

p.To avoid this problem, and for applications to work in older macOS, the <b>Deployment Target</b> parameter exists. When using it, a macro will be activated thatavoid the new features of the Base SDK. This will allow the program to run in old versions at the expense, of course, of not having access to the latest iMac features. You can select the Deployment Target through CMake options list, after pressing <c>[Configure]</c> <r>deployment_target</r>.

img(deployment_target.png,620,.65).Selection of the <b>Deployment Target</b> of our solution.
Selecting the Xcode Deployment Target from CMake.

bq.Xcode 8 considers Deployment Target to be less than 10.9 obsolete <r>deprecated_10_9</r>. Use Xcode 7 if you want support for Mac OSX 10.8 Mountain Lion and earlier. 

img(deprecated_10_9.png,-1,.45).Deployment Target 10.9 obsolete from Xcode 8.
Warning osx 10.9 deprecated.

h3.xcode-select

p.We have already seen that CMake only offers an option for Xcode, although it is possible to have several versions on the same machine, each within its own <c>Xcode.app</c> <i>bundle</i>. There will always be a default Xcode in the system (the most recent) but it can be changed using the <c>xcode-select</c> utility:

code.Check the current version of Xcode.
xcode-select -p
/Applications/Xcode.app/Contents/Developer
code.

code.Change of the active version of Xcode.
sudo xcode-select -s /Applications/Xcode8.app/Contents/Developer
code.

code.Set the default version of Xcode.
sudo xcode-select -r
code.

bq.You must press CMake <c>[Configure]</c> and <c>[Generate]</c> every time you use <c>xcode-select</c> so that your project updates the compiler change.

h3.macOS 32bits

p.Since the macOS High Sierra version, Apple has <l>https://support.apple.com/en-us/HT208436''declared obsolete</l> the architecture of 32 bits, issuing warnings to the users in the case of detecting executables <c>i386</c> <r>macos_32bit_warnings</r>. From Xcode 10, you can not compile in this architecture <r>macos_i386_error</r>.

img(macos_32bit_warnings.png,-1,.80).MacOS warnings in 32bit applications. 
Warning of macOS when trying to run 32bit applications.

img(macos_i386_error.png,520,.80).Error in Xcode 10 when trying to compile in 32bits.
Error message in Xcode 10 when compiled in 32bits.

bq.Support for 32-bit applications has definitely removed in <b>macOS Catalina</b>, which only allows 64-bit applications to run.

p.This makes some sense since all models of Intel iMac incorporate 64-bit processors, with the exception of a few 2006 models in white polycarbonate that mounted the 32-bit Intel Core Duo <r>imac32bits</r>. These iMac admitted at most the Mac OSX 10.6 Snow Leopard, being fundamental requirement from 10.7 Lion, the have a 64-bit CPU. To compile without problems in 32bits you have to use, at most, Xcode 6 <r>snow_leopard_debug</r>.

img(imac32bits.png,520,.65).Unique Apple models with Intel 32bit processor.
iMac, macBook and macMini with Intel 32bit processors.

img(snow_leopard_debug.png,0,.80).32 bits builds Xcode 3.2.6 (Snow Leopard).
Debugging the Die application from Xcode in Snow Leopard.

h2.Linux portability

p.In the Linux world, the <c>gcc</c> compiler and the <c>make</c> tool are used to generate the binaries, but there is no "official" development environment. To carry out an elementary configuration of our team in Ubuntu, type the following commands:

code(text).
sudo apt-get install gcc
sudo apt-get install g++
sudo apt-get install make
sudo apt-get install svn
sudo apt-get install cmake cmake-qt-gui
sudo apt-get install libgtk-3-dev
sudo apt-get install libglu1-mesa-dev freeglut3-dev mesa-common-dev
gsettings set org.gtk.Settings.Debug enable-inspector-keybinding true
code.

p.The work methodology does not change at all. We open CMake, select the directories, press <c>[Configure]</c> and then <c>[Generate]</c> <r>cmake_linux</r>.

img(cmake_linux.png,0,.80).Configuring CMake on Linux.
Configure the CMake directories on Linux.

p.In Linux we must use the CMake <c>Unix Makefiles</c> generator, which will create a series of <c>Makefile</c> scripts in <c>/home/fran/nappgui_build</c> (or the binary directory that we have selected). These <c>Makefile</c> contain the necessary commands to compile and link all the projects of the solution. We open a terminal:

code(text).Generate the solution through <c>make</c>.
cd /home/fran/nappgui_build
make
[ 15%] Building C object games/die/CMakeFiles/Die.dir/dgui.c.o
[ 30%] Building C object games/die/CMakeFiles/Die.dir/die.c.o
[ 45%] Building C object games/die/CMakeFiles/Die.dir/draw/ddraw.c.o
[ 60%] Building C object games/die/CMakeFiles/Die.dir/resgen/all.c.o
[ 75%] Linking CXX executable Debug/Die
[ 95%] Built target Die
code.

p.Once the compilation is finished, we can launch the executables directly from the terminal:

code(text).Launch the <i>Die</i> application.
./die/Debug/Die
code.

p.And if we are real hackers, we will be able to debug the programs directly from <c>gdb</c> <r>debug_gdb</r>.

code(text).Debugging <i>Die</i> with <i>gdb</i> <r>debug_gdb</r>.
gdb ./die/Debug/Die
(gdb) run
...
code.

img(debug_gdb.png,0,.80).Debugging <i>Die</i> with GDB from the terminal.
Using GDB to debug a C application.

h3.Eclipse CDT

p.Working directly with the terminal will give us the highest level of freedom possible to coding. With returning to the console and typing <c>make</c> everything necessary will be re-compiled. However, the use of <c>GDB</c> directly will be quite tedious, so we will make the leap to Eclipse CDT. This environment will allow us to program with a methodology similar to that of Visual Studio and Xcode: Situate breakpoints, inspect the stack and variables, search for files within the code directory, multiple editions, mass searches, etc.

bq.It is not imperative to use Eclipse. You can choose the editor/IDE you prefer.

p.The only difference is that we must use the generator <c>Eclipse CDT4 - Unix Makefiles</c> in CMake <r>make_generators</r> that in addition to <c>Makefile</c> will create the files <c>.cproject</c> and <c>.project</c> needed to import the project into Eclipse.

img(make_generators.png,0,.65).Generators based on <c>Makefile</c>. 
CMake Generators for Linux based on Makefile.

p.We open Eclipse and we do <c>File->Import->Existing Projects into Workspace</c>. A dialog box will appear where we indicate the <i>build</i> directory that we have configured in CMake (<c>/home/fran/nappgui_build</c>). Eclipse will open the project placing a tree with all the files on the left and we'll compile with <c>Project->Build All</c>. At the time of debugging (Die in this case) we will create a profile from <c>Run->Debug Configurations->C/C++ Application</c>. We press <c>[Search Project...]</c> and select <i>Die</i> from the drop-down list. Finally we press <c>[Debug]</c> to debug the application interactively <r>eclipse_debug</r>.

img(eclipse_debug.png,0,.80).Debugging the <i>Die</i> application with Eclipse.
Debugging the Die application from Eclipse.

p.Some interesting Eclipse CDT options under <c>Window->Preferences</c>.

li.Run/Debug->Launching->Terminate and Relaunch while launching.

h3.update-alternatives

p.NAppGUI supports the GCC compiler since version 4.3 (2008). Given the number of existing Linux distributions and that each one includes its own version of GCC, we will use Ubuntu as the reference operating system <r>gccvers</r>.

table(gccvers).GCC versions.
row.
p.
p.GCC
p.Ubuntu
row.
img(ubuntu_logo.png,32,.05).
p.8.3.0
p.18.10
row.
img(ubuntu_logo.png,32,.05).
p.7.3.0
p.18.04 LTS
row.
img(ubuntu_logo.png,32,.05).
p.5.3.1
p.16.04 LTS
row.
img(ubuntu_logo.png,32,.05).
p.4.8.2
p.14.04 LTS
row.
img(ubuntu_logo.png,32,.05).
p.4.6.3
p.12.04 LTS
row.
img(ubuntu_logo.png,32,.05).
p.4.4
p.10.04 LTS
table.

p.It is possible to have several versions of GCC installed on the same machine and to alternate between them in a similar way as we did with <c>xcode-select</c>, through utility <c>update-alternatives</c> of Linux. We assume that we are in Ubuntu 18.04:

code(text).Version of gcc installed.
gcc --version
gcc 7.4.0
code.

code(text).Install gcc-6.
sudo apt-get install gcc-6 g++-6
code.

code(text).Registry gcc-7 and gcc-6.
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 60 --slave /usr/bin/g++ g++ /usr/bin/g++-7
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-6 50 --slave /usr/bin/g++ g++ /usr/bin/g++-6
code.

code(text).Switch to gcc-6.
sudo update-alternatives --set gcc /usr/bin/gcc-6
gcc --version
gcc 6.5.0
g++ --version
g++ 6.5.0
code.

code(text).Return to the default version of gcc.
sudo update-alternatives --auto gcc
gcc --version
gcc 7.4.0
g++ --version
g++ 7.4.0
code.

h3.Toolkits

p.Unlike Windows and macOS, in Linux you can create user interfaces using different libraries (or <i>toolkits</i>) with GTK and Qt being the two most famous. NAppGUI uses GTK+3 for the graphical part in Linux (see <lh>Dependencies</lh>), although in the future it is possible that it also incorporates support for Qt, since it is the basis of the KDE desktop system, used in Kubuntu.

p.GTK+3 is found naturally in Ubuntu and many other distributions, although to compile it is necessary to install the developer version.

code(text).Install the development version of GTK+3.
sudo apt-get install libgtk-3-dev
code.

h3.Linux 32bits

p.To compile 32bit applications from an Ubuntu 64bits system it is necessary to install the package <c>multilib</c>:

code(text).
sudo apt-get install gcc-multilib
code.

p.But now there are <l>https://ubuntuforums.org/showthread.php?t=2038875''problems</l> to perform cross-compilation that includes the GTK+ library, so it will not be possible to use the same development machine to generate in both architectures, as in Windows. Console applications or libraries that do not access GTK can be compiled in 32bits from a 64bit computer.

bq.It is not possible to compile in 32bits from an Ubuntu system of 64bit applications that use GTK+3. 

h3.ARM architecture

p.The architecture <l>https://en.wikipedia.org/wiki/ARM_architecture''ARM</l> <i>Advanced RISC Machine</i> is the predominant in the market of embedded devices such as smartphones and tablets. Currently, NAppGUI does not offer support for the development of iOS/Android mobile applications, but for other types of boards that support versions of Linux ARM "desktop", such as the Raspberry PI with Raspbian. To carry our code to Raspberry Pi you have to follow the same steps as in Ubuntu Linux <r>raspberry_debug</r>. Both distributions are based on Debian, so we have GCC, CMake and Eclipse directly through <c>apt-get</c>. 

img(raspberry_debug.png,0,.80).Debugging the <i>Die</i> application on a Raspberry Pi. 
Debugging a C application on a Raspberry Pi, using Eclipse.

h2.Configurations

p.An NAppGUI application can be compiled in three different configurations, depending on the level of debugging we need.

li.<i>Debug</i>: Includes debug information in the binaries and code optimizations are not performed. It is the version for the developer.

li.<i>Release</i>: The debug information is removed and all possible optimizations are made. It is the version for the user. 

li.<i>ReleaseWithAssert</i>: It is the Release version, but leaving the statements active <lp>cassert</lp>. It is aimed at the end user, but in cases where it is necessary to obtain detailed information of possible anomalies, at the cost of a decrease in the overall performance of the program.

p.Both Visual Studio and Xcode are multi-configuration environments, that is, we can alternate between them directly from the editor itself. In Visual Studio we have a drop-down at the top of the editor <r>config_vs</r>.

img(config_vs.png,0,.65).Changing settings in Visual Studio.
Configuration selection menu in Visual Studio.

p.In Xcode is a bit more hidden. We make <c>Product->Scheme->Edit Scheme</c>. A pop-up window will appear. We select <c>Run->Info->Build Configuration</c> <r>config_xcode</r>.

img(config_xcode.png,0,.65).Change of configuration in Xcode.
Xcode configuration selection menu.

p.Unfortunately, <c>Unix make</c> does not support multiple configurations. This forces us to enter the property <c>CMAKE_BUILD_CONFIG</c> <r>config_cmake</r> to set the configuration in CMake before generating the <c>Makefile</c>. We will have to press again <c>[Configure]</c> and <c>[Generate]</c> for the new configuration to take effect.

img(config_cmake.png,0,.80).Changing settings in CMake (Unix Makefile).
Configuration selection menu in CMake.

h2.Installers

p.The last step, once a program has been created and refined, will be to create a package/installer that contains the executable and its possible dependencies, to distribute it comfortably to the final user. This packaging process has been automated in NAppGUI thanks to CPack, a utility included with CMake <r>packing</r>.

img(packing.png,0,.65).Packaging options in CMake.
CMake dashboard with packaging options.

li.Activate the <c>CMAKE_PACKAGE</c> option in the CMake panel.

li.Set in <c>CMAKE_PACKAGE_PATH</c> the directory where the generated packages are to be saved.

li.Select the type of packaging through the variable <c>CMAKE_PACKAGE_GEN</c> that admits three values:

lili.<c>TGZ</c>: Creates a compressed package <c>.tar.gz</c> that can be opened with any <c>.zip</c> utility installed on the computer <r>pack_tgz</r>. 

img(pack_tgz.png,0,.80).Packaging .tar.gz on Linux.
Packaging an application with .tar.gz.

lili.<c>DragNDrop</c>: (MacOS only). Create a <c>dmg</c> drive with a bundle <c>.app</c> and a link to the <c>/Applications</c> <r>pack_drag_n_drop</r> folder.

img(pack_drag_n_drop.png,0,.80).Dmg packaging in macOS.
Packaging an application in dmg.

lili.<c>NSIS</c>: (Windows only). Create an installer using the <i>Nullsoft scriptable install system</i> <r>pack_nsis</r> utility. It is necessary to have installed the software <l>https://nsis.sourceforge.io/Download''NSIS</l> (only to create the installer). The user who receives the package does not need to have such software installed.

img(pack_nsis.png,0,.80).NSIS installer.
NSIS installer with the application we just created.

p.Each package includes a copy of the license with which we are going to distribute the application. The content of it can be edited from the file <c>/res/license.txt</c> included in the resources directory of each project. 

bq.Packaging a program is time consuming. Activate <c>CMAKE_PACKAGE</c> only when we are going to distribute. During the development process it is advisable to deactivate the checkbox.
