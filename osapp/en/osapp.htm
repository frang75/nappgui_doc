langrev.
h1.OSApp

p.The <i>OSApp</i> library starts and manages the <b>message cycle</b> of a desktop application <r>osapp_depends</r>. Although the <b>Gui</b> library could be integrated into existing applications through a <i>plugin</i>, if we want to create an application from scratch, we will need to manage the events that the operating system sends to the program.

li.Use <lf>osmain</lf> to start a desktop application.

li.Use <lf>osapp_finish</lf> to end a desktop application.

img(osapp_depends.svg,300,.4).<i>OSApp</i> dependencies. See <lp>sdk</lp>.
Osapp library dependency tree.

h2.main() and osmain()

p.The classic <c>main</c> function is the starting point of any C/C++ command line program <r>main</r>. Its operation does not involve any difficulty and can be summarized in:

img(main.svg,420,.6).Running a console C application.
Scheme showing the main phases in the execution of a program in C/C++.

li(st01.svg,24).The operating system loads the program into memory and calls the function <c>main()</c> to start its execution.

li(st02.svg,24).The sentences are executed sequentially and in the order in which they are written. This order can be altered by means of control sentences (<c>for</c>, <c>if</c>, <c>switch</c>, etc.) or function calls.

li(st03.svg,24).If input/output is necessary, the program will wait for the communication to end and continue with the execution.

li(st04.svg,24).When the end of the function is reached <c>main ()</c> or an <c>exit()</c> sentence is executed, the program will end and the operating system will download it from memory.

p.However, in desktop applications (event driven), the execution cycle is a bit more complicated. In essence, the program is continuously executing a loop waiting for the user to perform some action <r>osmain</r> <r>skel</r>. In <lp>hello</lp> you have a simple example:

img(osmain.svg,480,.65).Running a desktop C application.
Scheme showing the main phases in the execution of a desktop program in C/C++.

li(st01.svg,24).The operating system loads the program into memory and calls the <c>main()</c> function. Now it is encapsulated inside the <lf>osmain</lf> macro which initiates certain structures necessary for event capture and management.

li(st02.svg,24).At some point in this initial process, the application constructor will be called (the first parameter of <c>osmain()</c>) that the main object should create. Since the program is continuously returning control to the operating system, the state of the data and windows will be maintained in this object.

li(st03.svg,24).Once initialized, the application will enter a loop known as a <b>message cycle</b> <r>runloop</r>, while waiting for the user to perform some action on the program interface.

img(runloop.svg,480,.6).Message cycle implementation.
Scheme showing how the message cycle is implemented in each operating system.

li(st04.svg,24).When this occurs, the operating system will capture the event and send it to the application.

li(st05.svg,24).If the application has defined a handle for that event, it will be invoked and the response code will be executed. An application can receive hundreds of messages but will only respond to those it deems necessary, ignoring the rest.

li(st06.svg,24).There is a special <b>exit</b> event that is generated by calling <lf>osapp_finish</lf>. When this happens, <c>osmain()</c> start freeing up resources and preparing a clean exit. At some point the destructor of the application will be called (second parameter of <c>osmain()</c>) to do its part of the job, closing possible open files and destroying the main object.

li(st07.svg,24).The operating system unload the application from memory.

li(pink_block.png,16).The pink blocks are platform dependent and are implemented within NAppGUI.

li(orange_block.png,16).The orange blocks are multiplatform (fully portable) and are implemented within the application.

code(cpp,skel).Elementary skeleton of a desktop application.
typedef struct _app_t App;
struct _app_t
{
    // Program data
    Window *window;
};

static App* i_create(void)
{
    App *app = heap_new(App);
    // Init program data, GUI and Event handlers
    app->window = ...
    return app;
}

static void i_destroy(App *app)
{
    // Destroy program data
    window_destroy(&(*app)->window);
    heap_delete(app, App);
}

osmain(i_create, i_destroy, "", App);
code.

h2.Synchronous applications

p.Certain types of applications including video games, media players or simulators, need to be updated at regular intervals, whether or not the user intervenes <r>synchronous_application</r> <r>skelsync</r>. For these cases we will need a variant of <c>osmain</c>, which accepts an update function and a time interval. In <lp>bricks</lp> you have an example.

li.Use <lf>osmain_sync</lf> to start a synchronous application.

img(synchronous_application.svg,480,.6).Events in synchronous applications.
Event graphic in synchronous applications.

code(cpp,skelsync).Elemental skeleton of a synchronous application.
typedef struct _app_t App;
struct _app_t
{
    // Program data
    Window *window;
};

static App* i_create(void)
{
    App *app = heap_new(App);
    // Init program data, GUI and Event handlers
    app->window = ...
    return app;
}

static void i_update(App *app, const real64_t prtime, const real64_t ctime)
{
    // Update program state every 40ms
}

static void i_destroy(App *app)
{
    // Destroy program data
    window_destroy(&(*app)->window);
    heap_delete(app, App);
}

osmain_sync(0.04, i_create, i_destroy, i_update, "", App);
code.

h2.Multi-threaded tasks

p.Both synchronous and asynchronous applications execute the message cycle on a single CPU thread. This means that if, in response to an event, a relatively slow task must be executed, the application will be "frozen" until it is finished <r>multithread_task</r><b>(a)</b>. This will produce an unwanted effect since the program will not respond for a few seconds, giving the impression that it has been blocked. The solution is to launch a task in parallel <r>multithread_task</r><b>(b)</b> <r>newtask</r>, quickly release the thread that manages the GUI. In <lh>Multi-threaded login</lh> you have an example of the use of tasks.

li.Use <lf>osapp_task</lf> to launch a new task in a parallel thread.

img(multithread_task.svg,560,.8).(a) Interface lock due to a slow function. (b) Slow function in a parallel thread.
Graph comparing code in one thread or several threads.

code(cpp,newtask).New task in a parallel thread.
// Runs in new thread
static uint32_t i_task_main(TaskData *data)
{
    // Do the task work here!
}

// Runs in GUI thread
static void i_task_update(TaskData *data)
{
    // Update the GUI here!
}

// Runs in GUI thread
static void i_task_end(TaskData *data, const uint32_t rvalue)
{
    // Finish task code here!
}

osapp_task(tdata, .04, i_task_main, i_task_update, i_task_end, TaskData);
code.

p.The new thread will begin its execution in <c>task_main</c>. This function <b>should not</b> access the interface elements, just perform calculations or input/output tasks. If it is necessary to update the GUI for the duration of the task (increasing a progress bar or similar), it must be done in <c>task_update</c>, indicating in <c>updtime</c> the update interval. The new thread will end when it returns from <c>task_main</c>, moment to be called <c>task_end</c> in the main thread. Obviously, if both threads access shared variables, they must be protected by a <lt>Mutex</lt>.

func(FPtr_app_create,ptr).An application constructor prototype.
fret(type*).Application object.

func(FPtr_app_update,ptr).Function prototype for update a synchronous application.
fpar(type*, app).Application object.
fpar(const real64_t, prtime).Previous update time.
fpar(const real64_t, ctime).Current time.

func(FPtr_task_main,ptr).Function prototype for start a task.
fret(uint32_t).Task return value.
fpar(type*,data).Initial task data.

func(FPtr_task_update,ptr).Function prototype of a task update.
fpar(type*,data).Task data.

func(FPtr_task_end,ptr).Function prototype of a task completion.
fpar(type*,data).Task Data.
fpar(const uint32_t,rvalue).Task return value.

func(osmain).Start a desktop application.
fpar(FPtr_app_create, func_create).Application object constructor.
fpar(FPtr_destroy, func_destroy).Application object destructor.
fpar(const char_t*, options).Options string.
fpar(,type).Type of application object.
fnote.In <lp>hello</lp> you have a simple example of desktop application.

func(osmain_sync).Start a synchronous desktop application.
fpar(const real64_t, lframe).Time in seconds of the update interval (0.04 = 25 fps).
fpar(FPtr_app_create, func_create).Application object constructor.
fpar(FPtr_destroy, func_destroy).Application object destructor.
fpar(FPtr_app_update, func_update).Function to be called in each update interval.
fpar(const char_t*, options).Options string.
fpar(,type).Type of application object.
fnote.See <lh>Synchronous applications</lh>.

func(osapp_finish).End a desktop application, destroying the message cycle and the application object.

func(osapp_task).Launch a task in parallel, avoiding the thread lock that controls the user interface.
fpar(type*,data).Initial task data.
fpar(const real32_t, updtime).Update interval time, if required.
fpar(FPtr_task_main, func_main).Task start function.
fpar(FPtr_task_update, func_update).Task update function.
fpar(FPtr_task_end, func_end).Function to be called when finishing the task.
fpar(,type).Type of initial task data.
fnote.See <lh>Multi-threaded tasks</lh>.

func(osapp_menubar).Set the general menu bar of the application.
fpar(Menu*,menu).The menu.
fpar(Window*,window).The window that will host the menu.
fnote.In macOS the application menu is not linked to any window.

func(osapp_open_url).Open an Internet address using the default operating system browser.
fpar(const char_t*,url).URL address.

